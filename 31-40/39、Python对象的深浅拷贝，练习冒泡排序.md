
@Author：By Runsen



@[toc]


# 对象的深浅拷贝

在Python有个重要的东西，就是对象的深浅拷贝。

我们就称为：'==' vs 'is'






- == 比较对象之间的值是否相等
- is 比较的是对象身份是否相等，它们是否同一个对象


我们一般通过id来是否相等来判断是否同一个对象

```python
a = 10
b = 10

a == b
True

id(a)
4427562448

id(b)
4427562448

a is b
True

```


注意a is b == True 只适合和用于-5 到256之间，这个不知道你是否知道，我觉得面试官肯定不知道。

```python
a = 257
b = 257

a == b
True

id(a)
4473417552

id(b)
4473417584

a is b
False

```

下面我们说下，浅拷贝和深拷贝


```python
l1 = [1, 2, 3]
l2 = list(l1)

l2
[1, 2, 3]

l1 == l2
True

l1 is l2
False

s1 = set([1, 2, 3])
s2 = set(s1)

s2
{1, 2, 3}

s1 == s2
True

s1 is s2
False

```
浅拷贝指重新分配一块内存，l2 就是l1的浅拷贝，但是只要是序列的浅拷贝，他们的id就是不一样的。




对于深拷贝，在python中提供了对应的函数copy.copy()

```python
import copy
l1 = [1, 2, 3]
l2 = copy.copy(l1)

t1 = (1, 2, 3)
t2 = tuple(t1)

t1 == t2
True

t1 is t2
True

```
元组（1，2，3）只被创建一次，t1和t2同时指向这个元组，反正你看到copy.copy()就是两个True




这里有一个天天来骗小孩的东西，就是l1变了，l2变不变的问题


我这里在使用的嵌套列表


```python
l1 = [[1, 2], (30, 40)]
l2 = list(l1)

l2
[[1, 2], (30, 40)]

l1.append(100)
l1[0].append(3)

l1
[[1, 2, 3], (30, 40), 100]

l2
[[1, 2, 3], (30, 40)]
```


l2竟然变了，这是为什么。首先初始化一个列表l1，里面的元素是一个列表和元组，然后对l1执行浅拷贝，赋予了l2
，但是l2中的元素和l1指向同一个列表和元组对象，只有列表对象变，你浅拷贝就要跟着我变。

如果你添加一个序列来，我浅拷贝没有指向你新来的对象。我干嘛跟着你变。

l1.append(100)l1的列表新增元素100，不会对l2产生影响，l1和l2是两个不同的对象



**如果我在元组加呢？？？**
```python

l1[1] += (50, 60)

l1
[[1, 2, 3], (30, 40, 50, 60), 100]

l2
[[1, 2, 3], (30, 40)]

```

竟然不会变，说白了只有列表对象变，难道元组不可变你不知道？






深度拷贝，就是你爱怎么变，就去哪里变，我就不变了。



```python
import copy
l1 = [[1, 2], (30, 40)]
l2 = copy.deepcopy(l1)
l1.append(100)
l1[0].append(3)

l1
[[1, 2, 3], (30, 40), 100]

l2 
[[1, 2], (30, 40)]

```

因为此时l1和l2完全独立了，没有任何影响

总结起来其实就是两句话

- 浅拷贝，不可变的不可变，可变的依旧可变
- 深拷贝，都不可变




下面我们练习下冒泡排序
# 冒泡排序
要学习冒泡排序必须知道它的原理：

所谓冒泡，就是将元素两两之间进行比较，谁大就往后移动，直到将最大的元素排到最后面，接着再循环一趟，从头开始进行两两比较，而上一趟已经排好的那个元素就不用进行比较了。（图中排好序的元素标记为黄色柱子）

说得不清楚，我们看看下面的动图就应该明白了







下面，我们就进入代码环节。

![](https://img-blog.csdnimg.cn/20200710225406469.png)

Python实现冒泡排序
现在，我给你一个nums = [3,1,25,6,8,10,15]，要求你用Python将nums实现冒泡排序。

看上去很难入手，其实很简单，我先给出代码

```csharp
nums = [3,1,25,6,8,10,15]
for i in range(len(nums)-1):
    for j in range(len(nums) - i -1):
        if nums[j] > nums[j+1]:
            nums[j],nums[j+1] =  nums[j+1],nums[j]
        print("第"+str(j)+"次内循环"+str(nums))
    print("第"+str(i)+"次外循环"+str(nums))
print("最后的结果"+str(nums))
```

我们先遍历nums，这不就是我们的range(len(nums)-1)，至于为什么是range(len(nums)-1)，其实就是我们的下标从0开始的，len(nums)返回是7，range是左开右闭，但是冒泡排序，我们只需要取到nums[5] = 10 就足够了，所以这里range(len(nums)-1)，取到[3,1,25,6,8,10]。

然后，我们在遍历之后的nums，比如i = 0，我们将j取值范围到len(nums) - i -1，用nums[j] > nums[j+1]判断两两的大小, 每次内循环将最大的移到最右边。

每一次内循环的目的就是将当中最大的移到最右边，而每一次外循环的目的就是当最大的移到最右边后，缩小范围，再寻找最大的数，再把它移到最右边。

我们执行上面的代码的结果如下：
```python
第0次内循环[1, 3, 25, 6, 8, 10, 15]
第1次内循环[1, 3, 25, 6, 8, 10, 15]
第2次内循环[1, 3, 6, 25, 8, 10, 15]
第3次内循环[1, 3, 6, 8, 25, 10, 15]
第4次内循环[1, 3, 6, 8, 10, 25, 15]
第5次内循环[1, 3, 6, 8, 10, 15, 25]
第0次外循环[1, 3, 6, 8, 10, 15, 25]
第0次内循环[1, 3, 6, 8, 10, 15, 25]
第1次内循环[1, 3, 6, 8, 10, 15, 25]
第2次内循环[1, 3, 6, 8, 10, 15, 25]
第3次内循环[1, 3, 6, 8, 10, 15, 25]
第4次内循环[1, 3, 6, 8, 10, 15, 25]
第1次外循环[1, 3, 6, 8, 10, 15, 25]
第0次内循环[1, 3, 6, 8, 10, 15, 25]
第1次内循环[1, 3, 6, 8, 10, 15, 25]
第2次内循环[1, 3, 6, 8, 10, 15, 25]
第3次内循环[1, 3, 6, 8, 10, 15, 25]
第2次外循环[1, 3, 6, 8, 10, 15, 25]
第0次内循环[1, 3, 6, 8, 10, 15, 25]
第1次内循环[1, 3, 6, 8, 10, 15, 25]
第2次内循环[1, 3, 6, 8, 10, 15, 25]
第3次外循环[1, 3, 6, 8, 10, 15, 25]
第0次内循环[1, 3, 6, 8, 10, 15, 25]
第1次内循环[1, 3, 6, 8, 10, 15, 25]
第4次外循环[1, 3, 6, 8, 10, 15, 25]
第0次内循环[1, 3, 6, 8, 10, 15, 25]
第5次外循环[1, 3, 6, 8, 10, 15, 25]
最后的结果[1, 3, 6, 8, 10, 15, 25]
```
我们可以看到，第0次外循环，已经将25放在了最右边，第1次外循环确定把15放到最右边，这样从右往左，从大到小，这就是完整的冒泡排序。







