
@Author：Runsen
@Date：2020/7/7


> 人生最重要的不是所站的位置，而是内心所朝的方向。只要我在每篇博文中写得自己体会，修炼身心；在每天的不断重复学习中，耐住寂寞，练就真功，不畏艰难，奋勇前行，不忘初心，砥砺前行，人生定会有所收获，不留遗憾 （作者：Runsen ）



作者介绍：Runsen目前大三下学期，专业化学工程与工艺，大学沉迷日语，Python， Java和一系列数据分析软件。导致翘课严重，专业排名中下。.在大学60%的时间，都在CSDN。决定今天比昨天要更加努力。


前面文章，点击下面链接

[我的Python教程，不断整理，反复学习](https://maoli.blog.csdn.net/article/details/106162925)

今天高考，当年我就是一个辣鸡，现在还是一个辣鸡，祝高考的个个清华北大
。辣鸡的我决定继续更新Python教程，今天就开始了八十五、Python | Leetcode数据结构之图和动态规划算法系列。

如果把基础的数据结构与算法都自己亲自实现一遍，那么你已经比 90% 的 Python 程序员更优秀了。

@[toc]

# 图



在计算机科学中，一个图就是一些顶点的集合，这些顶点通过一系列边结对（连接）。顶点用圆圈表示，边就是这些圆圈之间的连线。顶点之间通过边连接。
![](https://img-blog.csdnimg.cn/20190529212733348.png)

一个图G = (V, E)由以下元素组成。

-  V：一组顶点 

- E：一组边，连接V中的顶点 

# 度

表示一个顶点又多少条边


- 入度 表示又多少条变指向这个顶点
- 出度 表示这个顶点指出多少条边

# 邻接矩阵





在邻接矩阵实现中，由行和列都表示顶点，由两个顶点所决定的矩阵对应元素表示这里两个顶点是否相连、如果相连这个值表示的是相连边的权重。
![](https://img-blog.csdnimg.cn/2019052921325674.png)
- 无向图： 顶点 i 和顶点 j 之间有边，就将$A[i][j]$和$A[j][i]$ 标记为1  
- 有向图 如果 顶点i和顶点 j之间 ，有一条箭头从i指向 j 将$A[i][j]$ 标记为1 
- 有权图，数组存储相应的权重


还有 稀疏图。 稀疏图就是顶点多，但是每个顶点边并不多

应用：微信号几亿的用户，对应到图上就好几亿的顶点，但是每个用户的好友并不会很多，最多5000，如果用邻接矩阵来存储，那么存储空间都被浪费了


# 邻接表
![](https://img-blog.csdnimg.cn/20190529214855933.png)

邻接矩阵存储比较浪费时间，但是使用起来比较节省时间。相反邻接表存储起来比较节省空间，但是使用就比较浪费时间。

上图是否存在一条从顶点2到顶点4的边，就要遍历顶点2对应的链表



# 动态规划算法Dynamic Programming


先来看看生活中经常遇到的事吧——假设您是个土豪，身上带了足够的1、5、10、20、50、100元面值的钞票。现在您的目标是凑出某个金额w，需要用到尽量少的钞票。


依据生活经验，我们显然可以采取这样的策略：能用100的就尽量用100的，否则尽量用50的……依次类推。在这种策略下，666=6×100+1×50+1×10+1×5+1×1，共使用了10张钞票。


这种策略称为“贪心”：假设我们面对的局面是“需要凑出w”，贪心策略会尽快让w变得更小。能让w少100就尽量让它少100，这样我们接下来面对的局面就是凑出w-100。长期的生活经验表明，贪心策略是正确的。

但是，如果我们换一组钞票的面值，贪心策略就也许不成立了。如果一个奇葩国家的钞票面额分别是1、5、11，那么我们在凑出15的时候，贪心策略会出错：

15=1×11+4×1    （贪心策略使用了5张钞票）
15=3×5               （正确的策略，只用3张钞票）




再从一个简单的例子分析：
有 5 个物品，重量分别是 w = [1, 2, 3, 4, 5]；
对应的价值是 v = [1, 2, 4, 2, 5]；
背包容量 C = 10。


![](https://img-blog.csdnimg.cn/20200707155455779.png)


暴力法：对所有选择的组合，算出每一种情况的总价值，比较即可得出答案。


递归法：对于每个物品都有选与不选的决策，即原问题可以分解成两个子问题的比较。

假设有一个计算总价值的函数 F(n, c)，上述五个物品编号 i 为 1 ~ 5，c 是背包容量。
对于上例，第五个物品选择与否，通过比较两种子情况得到的价值大小来决定：

F(5, 10) = Max(F(4, 10) , F(4, 5) + 5)

故原问题有：

F(i, c) = Max( F(i-1, c), F(i-1, c - wi) + vi)

当然，如果背包剩余容量不足以容纳下一个物品，则再将 i-1。


![](https://img-blog.csdnimg.cn/2020070715560131.png)



动态规划：在递归的基础上储存已经求出的值。
当子问题重复出现时直接获取储存中的结果。
用一个 c*i 的二维数组储存——




![](https://img-blog.csdnimg.cn/20200707155644115.png)










#  Leetcode第64题：最小路径和


```csharp
#给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 
#
# 说明：每次只能向下或者向右移动一步。 
#
# 示例: 
#
# 输入:
#[
#  [1,3,1],
#  [1,5,1],
#  [4,2,1]
#]
#输出: 7
#解释: 因为路径 1→3→1→1→1 的总和最小。
# 
# Related Topics 数组 动态规划
```

本题dp实现采用数组实现，因为只能向右或者向下移动，要走到走到在第ｉ行第ｊ列的网格，必须是从第ｉ-1行第ｊ列的网格或者第ｉ行第ｊ-1列的网格移动过来，假设二维数组`dp[i][j]`表示在第ｉ行第ｊ列的网格上的最小数字总和



初始化dp所有的元素均为0，在网格的第一行和第一列的所有路径和应该都是固定的，因为都是向右或者向下移动

而当位置(i,j)处时，dp[i][j] = min(dp[i-1][j] +grid[i][j]，dp[i][j-1]++grid[i][j])，另外，二维数组是额外的辅助空间，如果将直接将原数组grid来存储dp数组的结果，边遍历边更新，对grid进行原地修改，可降低空间复杂度，如下．



```csharp
from typing import List
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n =len(grid[0])        
        #在网格的第一行和第一列的所有路径和应该都是固定的，直接向右或者向下移动相加
        for i in range(1,m):
            grid[i][0] += grid[i-1][0]
        for j in range(1,n):
            grid[0][j] += grid[0][j-1]            
        #非第一行和非第一列：
        for i in range(1,m):
            for j in range(1,n):
                grid[i][j]= min(grid[i-1][j] + grid[i][j], grid[i][j-1] + grid[i][j] )
        return grid[-1][-1]


if __name__ == "__main__":
    s=Solution()
    t=[[1,3,1],
      [1,5,1],
      [4,2,1]]
    print(s.minPathSum(t))
# result
7
```







# Leetcode第70题：爬楼梯


```csharp
#假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 
# 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 
# 注意：给定 n 是一个正整数。 
# 示例 1： 
# 输入： 2
#输出： 2
#解释： 有两种方法可以爬到楼顶。
#1.  1 阶 + 1 阶
#2.  2 阶 
# 示例 2： 
# 输入： 3
#输出： 3
#解释： 有三种方法可以爬到楼顶。
#1.  1 阶 + 1 阶 + 1 阶
#2.  1 阶 + 2 阶
#3.  2 阶 + 1 阶
# Related Topics 动态规划
```


动态规划：第一个想法就是利用递推公式求解方法数。
分析这个题目：

- 1 阶，f(1) = 1 种方案
- 2 阶，f(2) = 2 种方案
- 3 阶，f(3) = 3 种方案
- 4 阶，f(4) = 5 种方案

- n 阶，f(n) = f(n-1) + f(n-2) 种方案

即，该问题可以转换为斐波那契数列问题


优化空间复杂度：其实每次计算 f(i) 的值，都只用了离它最近的两个值，而没有用数组中其他的值。

也就是说我们根本不需要用一个数组来存放，只需要用两个变量来存放每次更新后最新得到的两个值即可。


```csharp
class Solution:
    def climbStairs(self, n: int) -> int:
        # 这里我们用prev curr分别存放离当前台阶数最近的两个台阶数对应的方法数。
        curr = prev = 1
        for _ in range(n-1):
            curr, prev = curr + prev, curr
        return curr


class Solution:
    def climbStairs(self, n, s1 = 0, s2 = 1):
        return n and self.climbStairs(n - 1, s2, s1 + s2) or s2
```











# Leetcode第322题： 零钱兑换

```csharp
#给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 
# 示例 1: 
# 输入: coins = [1, 2, 5], amount = 11
#输出: 3 
#解释: 11 = 5 + 5 + 1 
# 示例 2: 
# 输入: coins = [2], amount = 3
#输出: -1 
# 说明: 
#你可以认为每种硬币的数量是无限的。 
# Related Topics 动态规划
```




动态规划问题的一般形式就是求最值，求最值就是穷举所有的可能性。

```csharp

```

假设输入不同面额的硬币 coins = [coin1, coin2, coin3] , 总金额 amount


采用贪心算法做法： 对于 [1,2,5] 组成 11 块，排序[5,2,1]



- 取第一个5, 更新amout 为 11 - 5 = 6 继续更新 为 6 - 5 = 1 (退出

- 取第二个2   1 < 2 退出

- 取最后一个元素，也就是1


- amout 为 0 退出


因此结果是 3，但是贪心算法也有可能出错。 就拿这道题目来说，
它也是不正确的！ 比如 coins = [1, 5, 11] amout = 15, 因此这种做法有时候不靠谱，我们还是采用靠谱的做法。


因此需要dp算法，
用dp[i] 来表示组成i块钱，需要最少的硬币数，那么第j个硬币我可以选择不拿 这个时候， 硬币数 = dp[i]

第j个硬币我可以选择拿 这个时候， 硬币数 = dp[i - coins[j]] + 1

和背包问题不同， 硬币是可以拿任意个

对于每一个 dp[i] 我们都选择遍历一遍 coin， 不断更新 dp[i]。


这算是一道比较经典的动态规划题目了吧。关键是确定状态转移方程，如果当前组合dp[i]的个数小于另一i-1个组合+某一硬币的组合，则需要更新该值，所以可以得到状态转移方程如下：

```csharp
dp[i] = min(dp[i],dp[i-coin]+1)
```

那么就可以很容易地写出题解。


```csharp
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [amount + 1] * (amount + 1)
        dp[0] = 0

        for i in range(1, amount + 1):
            for j in range(len(coins)):
                if i >= coins[j]:
                    dp[i] = min(dp[i], dp[i - coins[j]] + 1)

        return -1 if dp[-1] == amount + 1 else dp[-1]
```

